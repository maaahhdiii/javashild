package com.security.ai.vulnerabilitydb;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.apache.hc.client5.http.classic.methods.HttpGet;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.impl.classic.HttpClients;
import org.apache.hc.core5.http.io.entity.EntityUtils;
import org.owasp.dependencycheck.Engine;
import org.owasp.dependencycheck.dependency.Dependency;
import org.owasp.dependencycheck.dependency.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.time.LocalDate;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Integrates with vulnerability databases (NVD, CVE, OWASP) to fetch
 * and correlate vulnerability information.
 */
public class VulnerabilityDatabaseService {
    
    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityDatabaseService.class);
    private static final String NVD_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0";
    
    private final Map<String, CVEDetails> cveCache = new ConcurrentHashMap<>();
    private final ObjectMapper objectMapper;
    private final OWASPDependencyChecker owaspChecker;
    
    public VulnerabilityDatabaseService() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
        this.owaspChecker = new OWASPDependencyChecker();
    }
    
    /**
     * Fetch CVE details from NVD
     */
    public Optional<CVEDetails> fetchCVEDetails(String cveId) {
        // Check cache first
        if (cveCache.containsKey(cveId)) {
            return Optional.of(cveCache.get(cveId));
        }
        
        try {
            String url = NVD_API_BASE + "?cveId=" + cveId;
            
            try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
                HttpGet request = new HttpGet(url);
                request.setHeader("Accept", "application/json");
                
                return httpClient.execute(request, response -> {
                    if (response.getCode() == 200) {
                        String jsonResponse = EntityUtils.toString(response.getEntity());
                        CVEDetails details = parseCVEResponse(jsonResponse, cveId);
                        
                        if (details != null) {
                            cveCache.put(cveId, details);
                            return Optional.of(details);
                        }
                    } else {
                        logger.warn("NVD API returned status: {} for CVE: {}", 
                            response.getCode(), cveId);
                    }
                    return Optional.empty();
                });
            }
            
        } catch (Exception e) {
            logger.error("Failed to fetch CVE details for: {}", cveId, e);
            return Optional.empty();
        }
    }
    
    /**
     * Parse CVE response from NVD API
     */
    private CVEDetails parseCVEResponse(String jsonResponse, String cveId) {
        try {
            JsonNode root = objectMapper.readTree(jsonResponse);
            JsonNode vulnerabilities = root.path("vulnerabilities");
            
            if (vulnerabilities.isArray() && vulnerabilities.size() > 0) {
                JsonNode cveNode = vulnerabilities.get(0).path("cve");
                
                String description = cveNode.path("descriptions").get(0).path("value").asText();
                LocalDate publishedDate = parseDate(cveNode.path("published").asText());
                LocalDate lastModifiedDate = parseDate(cveNode.path("lastModified").asText());
                
                // Extract CVSS scores
                JsonNode metricsNode = cveNode.path("metrics");
                Double cvssV3Score = extractCVSSV3Score(metricsNode);
                Double cvssV2Score = extractCVSSV2Score(metricsNode);
                String severity = determineSeverity(cvssV3Score, cvssV2Score);
                
                // Extract CWE
                List<String> cweIds = extractCWEIds(cveNode.path("weaknesses"));
                
                // Extract references
                List<String> references = extractReferences(cveNode.path("references"));
                
                return new CVEDetails(
                    cveId,
                    description,
                    severity,
                    cvssV3Score,
                    cvssV2Score,
                    cweIds,
                    publishedDate,
                    lastModifiedDate,
                    references
                );
            }
            
        } catch (Exception e) {
            logger.error("Failed to parse CVE response", e);
        }
        
        return null;
    }
    
    /**
     * Check dependencies for vulnerabilities using OWASP Dependency Check
     */
    public List<DependencyVulnerability> checkDependencies(File projectDirectory) {
        return owaspChecker.analyzeDependencies(projectDirectory);
    }
    
    /**
     * Search vulnerabilities by keyword
     */
    public List<CVEDetails> searchVulnerabilities(String keyword, int limit) {
        try {
            String url = NVD_API_BASE + "?keywordSearch=" + keyword + "&resultsPerPage=" + limit;
            
            try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
                HttpGet request = new HttpGet(url);
                request.setHeader("Accept", "application/json");
                
                return httpClient.execute(request, response -> {
                    List<CVEDetails> results = new ArrayList<>();
                    
                    if (response.getCode() == 200) {
                        String jsonResponse = EntityUtils.toString(response.getEntity());
                        JsonNode root = objectMapper.readTree(jsonResponse);
                        JsonNode vulnerabilities = root.path("vulnerabilities");
                        
                        for (JsonNode vulnNode : vulnerabilities) {
                            JsonNode cveNode = vulnNode.path("cve");
                            String cveId = cveNode.path("id").asText();
                            CVEDetails details = parseCVEResponse(vulnNode.toString(), cveId);
                            
                            if (details != null) {
                                results.add(details);
                                cveCache.put(cveId, details);
                            }
                        }
                    }
                    
                    return results;
                });
            }
            
        } catch (Exception e) {
            logger.error("Failed to search vulnerabilities", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Get vulnerabilities by date range
     */
    public List<CVEDetails> getVulnerabilitiesByDateRange(LocalDate startDate, LocalDate endDate) {
        try {
            String url = String.format("%s?pubStartDate=%s&pubEndDate=%s&resultsPerPage=100",
                NVD_API_BASE, startDate, endDate);
            
            try (CloseableHttpClient httpClient = HttpClients.createDefault()) {
                HttpGet request = new HttpGet(url);
                request.setHeader("Accept", "application/json");
                
                return httpClient.execute(request, response -> {
                    List<CVEDetails> results = new ArrayList<>();
                    
                    if (response.getCode() == 200) {
                        String jsonResponse = EntityUtils.toString(response.getEntity());
                        JsonNode root = objectMapper.readTree(jsonResponse);
                        JsonNode vulnerabilities = root.path("vulnerabilities");
                        
                        for (JsonNode vulnNode : vulnerabilities) {
                            String cveId = vulnNode.path("cve").path("id").asText();
                            CVEDetails details = parseCVEResponse(vulnNode.toString(), cveId);
                            
                            if (details != null) {
                                results.add(details);
                            }
                        }
                    }
                    
                    return results;
                });
            }
            
        } catch (Exception e) {
            logger.error("Failed to fetch vulnerabilities by date range", e);
            return Collections.emptyList();
        }
    }
    
    /**
     * Extract CVSS v3 score
     */
    private Double extractCVSSV3Score(JsonNode metricsNode) {
        JsonNode cvssV3 = metricsNode.path("cvssMetricV31").isArray() && 
                          metricsNode.path("cvssMetricV31").size() > 0
            ? metricsNode.path("cvssMetricV31").get(0)
            : metricsNode.path("cvssMetricV30").isArray() && 
              metricsNode.path("cvssMetricV30").size() > 0
                ? metricsNode.path("cvssMetricV30").get(0)
                : null;
        
        if (cvssV3 != null) {
            return cvssV3.path("cvssData").path("baseScore").asDouble();
        }
        
        return null;
    }
    
    /**
     * Extract CVSS v2 score
     */
    private Double extractCVSSV2Score(JsonNode metricsNode) {
        JsonNode cvssV2 = metricsNode.path("cvssMetricV2");
        
        if (cvssV2.isArray() && cvssV2.size() > 0) {
            return cvssV2.get(0).path("cvssData").path("baseScore").asDouble();
        }
        
        return null;
    }
    
    /**
     * Determine severity from CVSS scores
     */
    private String determineSeverity(Double cvssV3, Double cvssV2) {
        Double score = cvssV3 != null ? cvssV3 : cvssV2;
        
        if (score == null) return "UNKNOWN";
        if (score >= 9.0) return "CRITICAL";
        if (score >= 7.0) return "HIGH";
        if (score >= 4.0) return "MEDIUM";
        return "LOW";
    }
    
    /**
     * Extract CWE IDs
     */
    private List<String> extractCWEIds(JsonNode weaknessesNode) {
        List<String> cweIds = new ArrayList<>();
        
        if (weaknessesNode.isArray()) {
            for (JsonNode weaknessNode : weaknessesNode) {
                JsonNode descriptions = weaknessNode.path("description");
                
                if (descriptions.isArray()) {
                    for (JsonNode desc : descriptions) {
                        String cweId = desc.path("value").asText();
                        if (cweId.startsWith("CWE-")) {
                            cweIds.add(cweId);
                        }
                    }
                }
            }
        }
        
        return cweIds;
    }
    
    /**
     * Extract references
     */
    private List<String> extractReferences(JsonNode referencesNode) {
        List<String> references = new ArrayList<>();
        
        if (referencesNode.isArray()) {
            for (JsonNode refNode : referencesNode) {
                String url = refNode.path("url").asText();
                if (!url.isEmpty()) {
                    references.add(url);
                }
            }
        }
        
        return references;
    }
    
    /**
     * Parse date string
     */
    private LocalDate parseDate(String dateStr) {
        try {
            return LocalDate.parse(dateStr.substring(0, 10));
        } catch (Exception e) {
            return null;
        }
    }
    
    /**
     * CVE details record
     */
    public record CVEDetails(
        String cveId,
        String description,
        String severity,
        Double cvssV3Score,
        Double cvssV2Score,
        List<String> cweIds,
        LocalDate publishedDate,
        LocalDate lastModifiedDate,
        List<String> references
    ) {}
    
    /**
     * Dependency vulnerability record
     */
    public record DependencyVulnerability(
        String dependencyName,
        String version,
        String cveId,
        String severity,
        Double cvssScore,
        String description,
        List<String> recommendations
    ) {}
    
    /**
     * OWASP Dependency Checker wrapper
     */
    private static class OWASPDependencyChecker {
        private static final Logger logger = LoggerFactory.getLogger(OWASPDependencyChecker.class);
        
        List<DependencyVulnerability> analyzeDependencies(File projectDirectory) {
            List<DependencyVulnerability> vulnerabilities = new ArrayList<>();
            
            try {
                // Note: OWASP Dependency-Check API requires more complex setup in production
                // This is a simplified version for demo purposes
                logger.warn("OWASP Dependency-Check integration requires additional configuration");
                logger.info("For production use, configure OWASP Dependency-Check with proper settings");
                
                // Placeholder - in production, properly initialize Engine with Settings object
                // Engine engine = new Engine(settings);
                // engine.scan(projectDirectory);
                // ... process results
                
            } catch (Exception e) {
                logger.error("OWASP Dependency Check failed", e);
            }
            
            return vulnerabilities;
        }
        
        private String determineSeverityFromCvss(Float score) {
            if (score == null) return "UNKNOWN";
            if (score >= 9.0) return "CRITICAL";
            if (score >= 7.0) return "HIGH";
            if (score >= 4.0) return "MEDIUM";
            return "LOW";
        }
    }
}
